<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>算法题 | 前端工程师的自我修养</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.38a9b020.css" as="style"><link rel="preload" href="/assets/js/app.bd422e5c.js" as="script"><link rel="preload" href="/assets/js/2.df5b2971.js" as="script"><link rel="preload" href="/assets/js/17.8f3583bb.js" as="script"><link rel="prefetch" href="/assets/js/10.012f7eee.js"><link rel="prefetch" href="/assets/js/11.50dc0df0.js"><link rel="prefetch" href="/assets/js/12.8086b320.js"><link rel="prefetch" href="/assets/js/13.7656d892.js"><link rel="prefetch" href="/assets/js/14.2d9bc9d0.js"><link rel="prefetch" href="/assets/js/15.7fb91a03.js"><link rel="prefetch" href="/assets/js/16.6250c75c.js"><link rel="prefetch" href="/assets/js/18.7d75002f.js"><link rel="prefetch" href="/assets/js/19.a49801aa.js"><link rel="prefetch" href="/assets/js/20.50cc590b.js"><link rel="prefetch" href="/assets/js/21.6905bf0b.js"><link rel="prefetch" href="/assets/js/22.8725f98c.js"><link rel="prefetch" href="/assets/js/23.77a5b404.js"><link rel="prefetch" href="/assets/js/24.cd4f55e2.js"><link rel="prefetch" href="/assets/js/25.3eda7e20.js"><link rel="prefetch" href="/assets/js/26.dddc80b4.js"><link rel="prefetch" href="/assets/js/27.b57bb759.js"><link rel="prefetch" href="/assets/js/28.9fbc3100.js"><link rel="prefetch" href="/assets/js/29.1fd2d171.js"><link rel="prefetch" href="/assets/js/3.298f9aac.js"><link rel="prefetch" href="/assets/js/30.fbd714f0.js"><link rel="prefetch" href="/assets/js/31.8a5fedb3.js"><link rel="prefetch" href="/assets/js/32.fb1eae20.js"><link rel="prefetch" href="/assets/js/33.d9c1f3a4.js"><link rel="prefetch" href="/assets/js/34.ca467604.js"><link rel="prefetch" href="/assets/js/35.5b32b9f7.js"><link rel="prefetch" href="/assets/js/36.25127758.js"><link rel="prefetch" href="/assets/js/37.d77b4ce4.js"><link rel="prefetch" href="/assets/js/38.b7ad4073.js"><link rel="prefetch" href="/assets/js/39.401d4b5a.js"><link rel="prefetch" href="/assets/js/4.b1fee5de.js"><link rel="prefetch" href="/assets/js/40.2b4316ce.js"><link rel="prefetch" href="/assets/js/41.9c07dc76.js"><link rel="prefetch" href="/assets/js/42.1d1f3f7b.js"><link rel="prefetch" href="/assets/js/43.86317701.js"><link rel="prefetch" href="/assets/js/44.a934493f.js"><link rel="prefetch" href="/assets/js/45.bc7010a6.js"><link rel="prefetch" href="/assets/js/46.f02c3254.js"><link rel="prefetch" href="/assets/js/47.fa2b4df0.js"><link rel="prefetch" href="/assets/js/48.e7a14f9a.js"><link rel="prefetch" href="/assets/js/49.086ec92f.js"><link rel="prefetch" href="/assets/js/5.ffbf05fb.js"><link rel="prefetch" href="/assets/js/50.8d326e82.js"><link rel="prefetch" href="/assets/js/51.8d5a2045.js"><link rel="prefetch" href="/assets/js/52.905f3d60.js"><link rel="prefetch" href="/assets/js/53.ae6314b1.js"><link rel="prefetch" href="/assets/js/54.340e1e7b.js"><link rel="prefetch" href="/assets/js/55.18dbe46e.js"><link rel="prefetch" href="/assets/js/56.1fbedc1b.js"><link rel="prefetch" href="/assets/js/57.1ddb70a3.js"><link rel="prefetch" href="/assets/js/58.8363d3f9.js"><link rel="prefetch" href="/assets/js/59.2f4526a4.js"><link rel="prefetch" href="/assets/js/6.c8dddd28.js"><link rel="prefetch" href="/assets/js/60.fda5811b.js"><link rel="prefetch" href="/assets/js/7.ba1e7147.js"><link rel="prefetch" href="/assets/js/8.12b4acee.js"><link rel="prefetch" href="/assets/js/9.b24922ac.js">
    <link rel="stylesheet" href="/assets/css/0.styles.38a9b020.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端工程师的自我修养</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/nossika/FE-guide" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/nossika/FE-guide" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/ecma.html" class="sidebar-link">JS(ECMA)</a></li><li><a href="/js/dom.html" class="sidebar-link">JS(DOM/BOM)</a></li><li><a href="/js/engine.html" class="sidebar-link">V8引擎</a></li><li><a href="/js/thread.html" class="sidebar-link">单线程的JS</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>HTML/CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/htmlcss/html.html" class="sidebar-link">HTML</a></li><li><a href="/htmlcss/css.html" class="sidebar-link">CSS</a></li><li><a href="/htmlcss/render.html" class="sidebar-link">浏览器渲染</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>WEB</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web/protocol.html" class="sidebar-link">HTTP</a></li><li><a href="/web/cache.html" class="sidebar-link">缓存</a></li><li><a href="/web/crossorigin.html" class="sidebar-link">跨域</a></li><li><a href="/web/security.html" class="sidebar-link">安全</a></li><li><a href="/web/performance.html" class="sidebar-link">性能</a></li><li><a href="/web/cdn.html" class="sidebar-link">CDN</a></li><li><a href="/web/auth.html" class="sidebar-link">权限</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/communication.html" class="sidebar-link">组件通信</a></li><li><a href="/react/lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/react/api.html" class="sidebar-link">API</a></li><li><a href="/react/principle.html" class="sidebar-link">原理相关</a></li><li><a href="/react/lib.html" class="sidebar-link">第三方库</a></li><li><a href="/react/diff.html" class="sidebar-link">Vue vs React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/communication.html" class="sidebar-link">组件通信</a></li><li><a href="/vue/lifecycle.html" class="sidebar-link">生命周期</a></li><li><a href="/vue/api.html" class="sidebar-link">API</a></li><li><a href="/vue/principle.html" class="sidebar-link">原理相关</a></li><li><a href="/vue/lib.html" class="sidebar-link">官方库</a></li><li><a href="/vue/ssr.html" class="sidebar-link">SSR</a></li><li><a href="/vue/diff.html" class="sidebar-link">Vue vs React</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/structure.html" class="sidebar-link">数据结构</a></li><li><a href="/algorithm/concept.html" class="sidebar-link">概念</a></li><li><a href="/algorithm/application.html" class="active sidebar-link">算法题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/application.html#背包最大价值问题" class="sidebar-link">背包最大价值问题</a></li><li class="sidebar-sub-header"><a href="/algorithm/application.html#硬币凑整问题" class="sidebar-link">硬币凑整问题</a></li><li class="sidebar-sub-header"><a href="/algorithm/application.html#多个有序数组合并" class="sidebar-link">多个有序数组合并</a></li><li class="sidebar-sub-header"><a href="/algorithm/application.html#连续子数组的最大和" class="sidebar-link">连续子数组的最大和</a></li><li class="sidebar-sub-header"><a href="/algorithm/application.html#求字符串最长不重复子串" class="sidebar-link">求字符串最长不重复子串</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>计算机基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cs/paradigm.html" class="sidebar-link">编程范式</a></li><li><a href="/cs/design.html" class="sidebar-link">设计模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/engineer/module.html" class="sidebar-link">模块化</a></li><li><a href="/engineer/build.html" class="sidebar-link">构建</a></li><li><a href="/engineer/coop.html" class="sidebar-link">协作</a></li><li><a href="/engineer/test.html" class="sidebar-link">测试</a></li><li><a href="/engineer/deploy.html" class="sidebar-link">发布</a></li><li><a href="/engineer/monitor.html" class="sidebar-link">监控</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>NodeJS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/node/loop.html" class="sidebar-link">事件循环</a></li><li><a href="/node/module.html" class="sidebar-link">模块</a></li><li><a href="/node/npm.html" class="sidebar-link">NPM</a></li><li><a href="/node/app.html" class="sidebar-link">应用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>others</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/others/pwa.html" class="sidebar-link">PWA</a></li><li><a href="/others/graphql.html" class="sidebar-link">GraphQL</a></li><li><a href="/others/rxjs.html" class="sidebar-link">RxJS</a></li><li><a href="/others/webassembly.html" class="sidebar-link">WebAssembly</a></li><li><a href="/others/go.html" class="sidebar-link">Golang</a></li><li><a href="/others/docker.html" class="sidebar-link">Docker</a></li><li><a href="/others/database.html" class="sidebar-link">数据库</a></li><li><a href="/others/nginx.html" class="sidebar-link">nginx</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="算法题"><a href="#算法题" aria-hidden="true" class="header-anchor">#</a> 算法题</h1> <h2 id="背包最大价值问题"><a href="#背包最大价值问题" aria-hidden="true" class="header-anchor">#</a> 背包最大价值问题</h2> <p>有n个有各自价值和重量的物品，以及一个固定容量的背包，可以自由选择物品来放入背包，求背包能达到的最大价值。</p> <p>假设数据如下：</p> <pre><code>// 物品列表items: Array&lt;[价值, 重量]&gt;
const items = [[1,1],[3,4],[2,3],[30,48],[21,36],[12,11],[10,12],[15,16],[6, 12],[8, 22]];

// 背包容量capacity
const capacity = 39;
</code></pre> <h3 id="_1-求最大值"><a href="#_1-求最大值" aria-hidden="true" class="header-anchor">#</a> 1. 求最大值</h3> <p>对于前i个物品而言（假设第i个物品的价值为v[i]，重量为w[i]），此时最大值等于不放入第i个物品时的最大值和放入第i个物品时的最大值两者中取大。可以如下状态转移方程表示：</p> <p><code>f(i, capacity) = max{ f(i - 1, capacity), f(i - 1, capacity - w[i]) + v[i] }</code></p> <pre><code>function getVal(i, capacity) {
  const [weight, value] = items[i];
  if (i === 0) {
    if (capacity &lt; weight) return 0;
    return value;
  }
  return capacity &gt;= weight ? Math.max(getVal(i - 1, capacity), getVal(i - 1, capacity - weight) + value) : getVal(i - 1, capacity);
}

getVal(items.length - 1, capacity); // 75
</code></pre> <h3 id="_2-求最大值及其方案"><a href="#_2-求最大值及其方案" aria-hidden="true" class="header-anchor">#</a> 2. 求最大值及其方案</h3> <p>在算法1的基础上加入bag数组来记录当前解法用到的物品</p> <pre><code>function getVal(i, capacity, bag) {
  const [weight, value] = items[i];

  if (i === 0) {
    if (capacity &lt; weight) return [0, bag];
    return [value, bag.concat(0)];
  }

  let [unputVal, unputBag] = getVal(i - 1, capacity, bag);

  if (capacity &gt;= weight) {
    let [putVal, putBag] = getVal(i - 1, capacity - weight, bag);
    putVal += value;
  
    if (putVal &gt; unputVal) {
      return [putVal, putBag.concat(i)];
    } else {
      return [unputVal, unputBag];
    }
  } else {
    return [unputVal, unputBag];
  }
}

getVal(items.length - 1, capacity, []); // [75, [0, 1, 4, 8, 9]]
</code></pre> <h3 id="_3-物品带数量时的最大值"><a href="#_3-物品带数量时的最大值" aria-hidden="true" class="header-anchor">#</a> 3. 物品带数量时的最大值</h3> <p>基于算法1作拓展，此时物品i不再是放入或者不放入（放入0个或1个），而是可以放入k个，k是一个有限整数集合，满足<code>0 &lt;= k &lt;= limit</code>且<code>w[i] * k &lt;= capacity</code>，则状态转移方程应该改为</p> <p><code>f(i, capacity) = max{ f(i - 1, capacity - w[i] * k) + v[i] * k } (0 &lt;= k &lt;= limit &amp; w[i] * k &lt;= capacity)</code></p> <pre><code>// 带数量的物品列表itemsWithLimit: Array&lt;[价值, 重量, 数量]&gt;
const itemsWithLimit = [[1,1,3],[3,4,5],[2,3,1],[30,48,1],[21,36,2]];

function getVal(i, capacity) {
  const [weight, value, limit] = itemsWithLimit[i];
  if (i === 0) {
    return Math.min((capacity / weight | 0), limit) * value;
  }
  const solutions = [];
  for (let k = 0; weight * k &lt;= capacity &amp;&amp; k &lt;= limit; k++) {
    solutions.push(getVal(i - 1, capacity - weight * k) + value * k);
  }
  return Math.max(...solutions);
}

getVal(itemsWithLimit.length - 1, capacity); // 58
</code></pre> <h2 id="硬币凑整问题"><a href="#硬币凑整问题" aria-hidden="true" class="header-anchor">#</a> 硬币凑整问题</h2> <p>有i种面值不同的硬币，数量不限，需要用这i种硬币凑出刚好为n的数额</p> <p>假设数据如下：</p> <pre><code>// 硬币种类coins: Array&lt;面值&gt;
const coins = [1, 2, 5, 10, 20];

// 目标数额n
const n = 98;
</code></pre> <h3 id="_1-求全部解法数量"><a href="#_1-求全部解法数量" aria-hidden="true" class="header-anchor">#</a> 1. 求全部解法数量</h3> <p>使用前i种coin的解法数 = 仅使用前i-1种coin的解法数 + 用上第i种coin的解法数</p> <pre><code>function coinsSolutions(coins, n) {

  // 保证coins数组是升序的
  coins.sort((a, b) =&gt; a - b);

  // 用于存放函数use1 use2 use3...use{i}，函数参数为目标数值n，返回值为仅用前i种coin能凑出的解法数
  const solutions = {};

  for (let [index, value] of coins.entries()) {
    
    // 只用第一种coin时特殊处理，如果n能被面值整除，则返回解法数为1，否则返回解法数0
    if (index === 0) {
      solutions['use1'] = function(n) {
        return n % value === 0 ? 1 : 0;
      }
      continue;
    }

    // 使用前i种coin的解法数 = 仅使用前i-1种coin的解法数 + 用上第i种coin的解法数
    // (JS相关)可使用new Function来动态定义函数，因为new Function内的作用域默认为全局作用域，无法访问solutions对象，这里使用with+bind的写法来把solutions传进其作用域
    solutions['use' + (index + 1)] = new Function(
      'n', 
      `with(this){
        let result = 0;
        for (let i = n; i &gt;= 0; i = i - ${value}) {
          result += use${index}(i);
        }
        return result;
      }`
    ).bind(solutions);
  }

  // 最后的解等于所有coin种类都用上的解
  return solutions['use' + coins.length](n);
} 
</code></pre> <h3 id="_2-求最少使用的硬币数"><a href="#_2-求最少使用的硬币数" aria-hidden="true" class="header-anchor">#</a> 2. 求最少使用的硬币数</h3> <p>此问题解法和背包问题类似，每个硬币数量对应的value为1，求最小value。</p> <p>使用前i种硬币凑成的数额n = (仅使用前i-1种硬币凑成n - coins[i] * k) + (单独使用k个第i种硬币凑成coins[i] * k)</p> <p>即前i种硬币凑成n的最少硬币个数的状态转移方程为：</p> <p><code>f(n, i) = min{ f(n - coins[i] * k, i - 1) + k } (k &gt;= 0 &amp; coins[i] * k &lt;= n)</code></p> <pre><code>function coinsMinSolution(coins, n) {
  coins.sort((a, b) =&gt; a - b);

  function getMin(n, i) {
    // 仅使用第1种硬币时，n能整除面值，则数量为n/面值，否则设为无穷大，在后面的Math.min比较时忽略此解法 
    if (i === 0) {
      return n % coins[0] === 0 ? n / coins[0] : Infinity;
    }

    // 写出状态转移方程，循环k来测试它，找出其最小值
    const solutions = [];
    for (let k = 0; coins[i] * k &lt;= n; k++) {
      solutions.push(getMin(n - coins[i] * k, i - 1) + k);
    }
    return Math.min(...solutions);
  }

  return getMin(n, coins.length - 1);
}
</code></pre> <h2 id="多个有序数组合并"><a href="#多个有序数组合并" aria-hidden="true" class="header-anchor">#</a> 多个有序数组合并</h2> <pre><code>const arr1 = [2,5,7];
const arr2 = [1,4,7,9];
const arr3 = [0,3,4,8];

function mergeOrderedArr(arrs) {
  const result = new Array(arrs.reduce((acc, arr) =&gt; acc + arr.length, 0)); // 排序结果数组
  const idxArr = new Array(arrs.length).fill(0); // idx数组，idx对应arrs的每个arr，表示各个arr当前遍历到的位置

  // 在每个arr剩余的第一项中进行对比，最小的取出放入result，并且该数组idx+1表示该项已被取出
  for (let i = 0; i &lt; result.length; i++) {
    let min = Infinity;
    let minArr = 0;

    for (let j = 0; j &lt; arrs.length; j++) {
      let num = arrs[j][idxArr[j]];

      if (min &gt; num) {
        min = num;
        minArr = j;
      }
    }

    idxArr[minArr] = idxArr[minArr] + 1;
    result[i] = min;
  }

  return result;
}

mergeOrderedArr([arr1, arr2, arr3]); // [0, 1, 2, 3, 4, 4, 5, 7, 7, 8, 9]
</code></pre> <h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" aria-hidden="true" class="header-anchor">#</a> 连续子数组的最大和</h2> <p>用f(i)表示arr中以第i项为结尾的连续子数组的最大和，则其状态转移方程如下</p> <p><code>f(i) = max{ f(i - 1) + arr[i], arr[i] }</code></p> <p>求出每一个f(i)的值，再从中取最大值作为最后结果</p> <p><code>result = max{ f(i) } (0 &lt;= i &lt;= arr.length - 1)</code></p> <pre><code>function getMax(arr) {

  // 设置缓存数组，cache[i]表示以第i项为结尾的连续子数组的最大和
  const cache = [];

  function getMaxEndWithIndex(i) {
    if (i === 0) {
      cache[i] = arr[i];
    }
    if (!cache[i]) {
      cache[i] = Math.max(getMaxEndWithIndex(i - 1) + arr[i], arr[i]);
    }
    return cache[i];
  }

  // 计算包含最后一项的子数组的最大和，因为每一项的结果都依赖于前一项，利用此过程递归求出所有项的结果
  getMaxEndWithIndex(arr.length - 1);
  
  return Math.max(...cache);

}
</code></pre> <h2 id="求字符串最长不重复子串"><a href="#求字符串最长不重复子串" aria-hidden="true" class="header-anchor">#</a> 求字符串最长不重复子串</h2> <ol><li><p>定义start、end两个指针，起始位置为0，初始化max为0</p></li> <li><p>将start、end指向起始位置，初始化缓存列表</p></li> <li><p>end不断向后移动，并将指向的值存入缓存，直到end指向的字母已存在缓存中（说明出现了重复字符），计算end - start的值并与max比较，保留大者</p></li> <li><p>起始位置+1（即start+1），重复步骤2，直到 str.length - start &gt; max 时（此时再继续下去也不会出现更大的max），停止循环，输出max</p> <p>function lengthOfLongestSubstring(str) {
let start = 0;
let end = 0;
let max = 0;
while (str.length - start &gt; max) {
end = start;
const charCache = new Set();
while (true) {
const char = str[end];
if (!char || charCache.has(char)) {
max = Math.max(max, end - start);
break;
}
charCache.add(char);
end++;
}
start++;
}
return max;
};</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/algorithm/concept.html" class="prev">
          概念
        </a></span> <span class="next"><a href="/cs/paradigm.html">
          编程范式
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.bd422e5c.js" defer></script><script src="/assets/js/2.df5b2971.js" defer></script><script src="/assets/js/17.8f3583bb.js" defer></script>
  </body>
</html>
