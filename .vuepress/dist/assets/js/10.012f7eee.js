(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{196:function(t,e,v){t.exports=v.p+"assets/img/https.d725e9d1.png"},206:function(t,e,v){"use strict";v.r(e);var a=v(0),_=Object(a.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),a("h2",{attrs:{id:"http-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP")]),t._v(" "),a("p",[t._v("基于tcp协议，req格式： "),a("code",[t._v("HTTP/1.1 /index.html GET\\r\\nConnection: keep-alive")]),t._v("，res格式："),a("code",[t._v("HTTP/1.1 200 OK\\r\\nContent-type: text/plain\\r\\n\\r\\nsome text here")])]),t._v(" "),a("p",[t._v("1.1默认keep-alive，基于一次tcp（3次握手4次挥手）来发多次http请求")]),t._v(" "),a("p",[t._v("状态码12345")]),t._v(" "),a("p",[t._v("header(content-type/accept-encoding/user-agent/cookie/access-control-allow-origin/cache-control/e-tag/connection)")]),t._v(" "),a("p",[t._v("缓存控制")]),t._v(" "),a("p",[t._v("cookie")]),t._v(" "),a("h3",{attrs:{id:"http-code-vs-body-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-code-vs-body-code","aria-hidden":"true"}},[t._v("#")]),t._v(" http code VS body code")]),t._v(" "),a("p",[t._v("可以类比TCP/QUIC，在 直接利用现有协议/在协议下层精细化封装 之间的取舍。")]),t._v(" "),a("h2",{attrs:{id:"tcp-udp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP/UDP")]),t._v(" "),a("p",[t._v("都基于IP的传输层协议，传输数据给应用层协议使用。")]),t._v(" "),a("p",[t._v("因为都基于网络层的IP，两者都可能会出现丢包或乱序。而TCP与UDP不同的是，它在协议层封装了滑动窗口（超时重传来控制顺序、控制并发数来合理利用带宽）来解决这些问题。基于UDP也同样可以在应用层自行封装实现TCP的功能，比如谷歌的QUIC。")]),t._v(" "),a("h3",{attrs:{id:"quic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quic","aria-hidden":"true"}},[t._v("#")]),t._v(" QUIC")]),t._v(" "),a("h2",{attrs:{id:"https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),a("p",[t._v("HTTP是明文传输，且没有对来源校验，通信内容易受中间人的监视和篡改。所以需要对通信内容加密来解决问题，其中最关键的是保证密钥的正确和安全。")]),t._v(" "),a("p",[t._v("HTTPS引入了CA来解决问题，CA是一个权威机构，负责给受信的网站颁发证书，证书包含一对公私钥，私钥由网站保管，公钥对外公开。现代浏览器会内置CA的公共信息。")]),t._v(" "),a("p",[t._v("HTTP：IP -> TCP -> HTTP")]),t._v(" "),a("p",[t._v("HTTPS: IP -> TCP -> "),a("strong",[t._v("SSL/TLS")]),t._v(" -> HTTP")]),t._v(" "),a("blockquote",[a("p",[t._v("公钥私钥涉及非对称加密的知识，相关内容详见"),a("a",{attrs:{href:"/web/safe?id=%E5%86%85%E5%AE%B9%E5%8A%A0%E5%AF%86"}},[t._v("【内容加密】")])])]),t._v(" "),a("p",[t._v("HTTPS通信过程如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:v(196),alt:"HTTPS"}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Client发起请求")])]),t._v(" "),a("li",[a("p",[t._v("Server收到请求，返回明文证书内容（包含网站信息、签发机构CA信息、证书有效期等）和证书签名（对"),a("strong",[t._v("证书内容hash")]),t._v("用CA私钥加密后得到的签名）")])]),t._v(" "),a("li",[a("p",[t._v("Client收到证书后，从"),a("strong",[t._v("内置的CA证书表")]),t._v("中，取出和Server证书对应的CA公钥，解密签名，将签名数据与证书内容比对，若一致，则说明此签名一定是CA私钥持有方签发的，即可认为此证书来源可信（这步的关键之处在于CA公钥是从本地直接取得的，保证公钥绝对可信）")])]),t._v(" "),a("li",[a("p",[t._v("Client"),a("strong",[t._v("生成对称密钥key")]),t._v("，将key用CA公钥加密后发给Server，这个加密能确保没有CA私钥的人无法拿到key")])]),t._v(" "),a("li",[a("p",[t._v("Server收到加密内容后，用CA私钥解密出key，之后双方即可用这个key来进行加密通信")])])]),t._v(" "),a("h2",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2","aria-hidden":"true"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),a("p",[t._v("相比HTTP的改进点：")]),t._v(" "),a("ol",[a("li",[t._v("编码方式：文本 => 二进制")]),t._v(" "),a("li",[t._v("多路复用：一个tcp连接中同时发起多个http请求，而不是一个http请求完毕才能发下一个")]),t._v(" "),a("li",[t._v("头部压缩：客户端/服务端都维护一个headers索引表，请求不再每次都带上完整headers")]),t._v(" "),a("li",[t._v("主动推送：可以在客户端请求html时，把相关css、js也一并推送（需要服务端配置）")])]),t._v(" "),a("p",[t._v("区分HTTP：")]),t._v(" "),a("p",[t._v("HTTP2的headers风格是（冒号+）全小写+连字符，比如"),a("code",[t._v(":method")]),t._v("、"),a("code",[t._v("user-agent")]),t._v("等，HTTP1的风格是首字母大写+连字符。")]),t._v(" "),a("p",[t._v("HTTP2必须基于HTTPS，虽然HTTP2协议本身并不要求HTTPS，但各浏览器的实现都要求HTTP2必须用HTTPS。")]),t._v(" "),a("h2",{attrs:{id:"websocket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket","aria-hidden":"true"}},[t._v("#")]),t._v(" websocket")]),t._v(" "),a("p",[t._v("和http一样基于tcp，http协议的升级")]),t._v(" "),a("p",[t._v("tcp连接（连接实例称为socket）建立后，客户端发送http格式的报文"),a("code",[t._v("{ Connection: Upgrade, Upgrade: websocket, ... }")]),t._v("，服务端如果支持，也返回类似的确认报文，双方都对这个socket做好全双工通信的准备，即websocket连接建立。")]),t._v(" "),a("h3",{attrs:{id:"socket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket","aria-hidden":"true"}},[t._v("#")]),t._v(" socket")]),t._v(" "),a("p",[t._v("套接字，可以理解为一个连接的实例，\n比如说服务端客户端建立起一个tcp连接，那么两端各会有一个socket实例，可以对其调用各种方法来收发信息。")]),t._v(" "),a("h2",{attrs:{id:"七层模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七层模型","aria-hidden":"true"}},[t._v("#")]),t._v(" 七层模型")]),t._v(" "),a("p",[t._v("应用：http")]),t._v(" "),a("p",[t._v("会话：ssl/tls")]),t._v(" "),a("p",[t._v("传输：tcp/udp")]),t._v(" "),a("p",[t._v("网络：ip")])])},[],!1,null,null,null);e.default=_.exports}}]);