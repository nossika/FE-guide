(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{205:function(n,t,i){"use strict";i.r(t);var a=i(0),e=Object(a.a)({},function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h1",{attrs:{id:"算法题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#算法题","aria-hidden":"true"}},[n._v("#")]),n._v(" 算法题")]),n._v(" "),i("h2",{attrs:{id:"背包最大价值问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#背包最大价值问题","aria-hidden":"true"}},[n._v("#")]),n._v(" 背包最大价值问题")]),n._v(" "),i("p",[n._v("有n个有各自价值和重量的物品，以及一个固定容量的背包，可以自由选择物品来放入背包，求背包能达到的最大价值。")]),n._v(" "),i("p",[n._v("假设数据如下：")]),n._v(" "),i("pre",[i("code",[n._v("// 物品列表items: Array<[价值, 重量]>\nconst items = [[1,1],[3,4],[2,3],[30,48],[21,36],[12,11],[10,12],[15,16],[6, 12],[8, 22]];\n\n// 背包容量capacity\nconst capacity = 39;\n")])]),n._v(" "),i("h3",{attrs:{id:"_1-求最大值"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-求最大值","aria-hidden":"true"}},[n._v("#")]),n._v(" 1. 求最大值")]),n._v(" "),i("p",[n._v("对于前i个物品而言\b（假设第i个物品的价值为v[i]，重量为w[i]），此时最大值等于不放入第i个物品时的最大值和放入第i个物品时的最大值两者中取大。可以如下状态转移方程表示：")]),n._v(" "),i("p",[i("code",[n._v("f(i, capacity) = max{ f(i - 1, capacity), f(i - 1, capacity - w[i]) + v[i] }")])]),n._v(" "),i("pre",[i("code",[n._v("function getVal(i, capacity) {\n  const [weight, value] = items[i];\n  if (i === 0) {\n    if (capacity < weight) return 0;\n    return value;\n  }\n  return capacity >= weight ? Math.max(getVal(i - 1, capacity), getVal(i - 1, capacity - weight) + value) : getVal(i - 1, capacity);\n}\n\ngetVal(items.length - 1, capacity); // 75\n")])]),n._v(" "),i("h3",{attrs:{id:"_2-求最大值及其方案"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-求最大值及其方案","aria-hidden":"true"}},[n._v("#")]),n._v(" 2. 求最大值及其方案")]),n._v(" "),i("p",[n._v("在算法1的基础上加入bag数组来记录当前解法用到的物品")]),n._v(" "),i("pre",[i("code",[n._v("function getVal(i, capacity, bag) {\n  const [weight, value] = items[i];\n\n  if (i === 0) {\n    if (capacity < weight) return [0, bag];\n    return [value, bag.concat(0)];\n  }\n\n  let [unputVal, unputBag] = getVal(i - 1, capacity, bag);\n\n  if (capacity >= weight) {\n    let [putVal, putBag] = getVal(i - 1, capacity - weight, bag);\n    putVal += value;\n  \n    if (putVal > unputVal) {\n      return [putVal, putBag.concat(i)];\n    } else {\n      return [unputVal, unputBag];\n    }\n  } else {\n    return [unputVal, unputBag];\n  }\n}\n\ngetVal(items.length - 1, capacity, []); // [75, [0, 1, 4, 8, 9]]\n")])]),n._v(" "),i("h3",{attrs:{id:"_3-物品带数量时的最大值"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-物品带数量时的最大值","aria-hidden":"true"}},[n._v("#")]),n._v(" 3. 物品带数量时的最大值")]),n._v(" "),i("p",[n._v("基于算法1作拓展，此时物品i不再是放入或者不放入（放入0个或1个），而是可以放入k个，k是一个有限整数集合，满足"),i("code",[n._v("0 <= k <= limit")]),n._v("且"),i("code",[n._v("w[i] * k <= capacity")]),n._v("，则状态转移方程应该改为")]),n._v(" "),i("p",[i("code",[n._v("f(i, capacity) = max{ f(i - 1, capacity - w[i] * k) + v[i] * k } (0 <= k <= limit & w[i] * k <= capacity)")])]),n._v(" "),i("pre",[i("code",[n._v("// 带数量的物品列表itemsWithLimit: Array<[价值, 重量, 数量]>\nconst itemsWithLimit = [[1,1,3],[3,4,5],[2,3,1],[30,48,1],[21,36,2]];\n\nfunction getVal(i, capacity) {\n  const [weight, value, limit] = itemsWithLimit[i];\n  if (i === 0) {\n    return Math.min((capacity / weight | 0), limit) * value;\n  }\n  const solutions = [];\n  for (let k = 0; weight * k <= capacity && k <= limit; k++) {\n    solutions.push(getVal(i - 1, capacity - weight * k) + value * k);\n  }\n  return Math.max(...solutions);\n}\n\ngetVal(itemsWithLimit.length - 1, capacity); // 58\n")])]),n._v(" "),i("h2",{attrs:{id:"硬币凑整问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#硬币凑整问题","aria-hidden":"true"}},[n._v("#")]),n._v(" 硬币凑整问题")]),n._v(" "),i("p",[n._v("有i种面值不同的硬币，数量不限，需要用这i种硬币凑出刚好为n的数额")]),n._v(" "),i("p",[n._v("假设数据如下：")]),n._v(" "),i("pre",[i("code",[n._v("// 硬币种类coins: Array<面值>\nconst coins = [1, 2, 5, 10, 20];\n\n// 目标数额n\nconst n = 98;\n")])]),n._v(" "),i("h3",{attrs:{id:"_1-求全部解法数量"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-求全部解法数量","aria-hidden":"true"}},[n._v("#")]),n._v(" 1. 求全部解法数量")]),n._v(" "),i("p",[n._v("使用前i种coin的解法数 = 仅使用前i-1种coin的解法数 + 用上第i种coin的解法数")]),n._v(" "),i("pre",[i("code",[n._v("function coinsSolutions(coins, n) {\n\n  // 保证coins数组是升序的\n  coins.sort((a, b) => a - b);\n\n  // 用于存放函数use1 use2 use3...use{i}，函数参数为目标数值n，返回值为仅用前i种coin能凑出的解法数\n  const solutions = {};\n\n  for (let [index, value] of coins.entries()) {\n    \n    // 只用第一种coin时特殊处理，如果n能被面值整除，则返回解法数为1，否则返回解法数0\n    if (index === 0) {\n      solutions['use1'] = function(n) {\n        return n % value === 0 ? 1 : 0;\n      }\n      continue;\n    }\n\n    // 使用前i种coin的解法数 = 仅使用前i-1种coin的解法数 + 用上第i种coin的解法数\n    // (JS相关)可使用new Function来动态定义函数，因为new Function内的作用域默认为全局作用域，无法访问solutions对象，这里使用with+bind的写法来把solutions传进其作用域\n    solutions['use' + (index + 1)] = new Function(\n      'n', \n      `with(this){\n        let result = 0;\n        for (let i = n; i >= 0; i = i - ${value}) {\n          result += use${index}(i);\n        }\n        return result;\n      }`\n    ).bind(solutions);\n  }\n\n  // 最后的解等于所有coin种类都用上的解\n  return solutions['use' + coins.length](n);\n} \n")])]),n._v(" "),i("h3",{attrs:{id:"_2-求最少使用的硬币数"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-求最少使用的硬币数","aria-hidden":"true"}},[n._v("#")]),n._v(" 2. 求最少使用的硬币数")]),n._v(" "),i("p",[n._v("此问题解法和背包问题类似，每个硬币数量对应的value为1，求最小value。")]),n._v(" "),i("p",[n._v("使用前i种硬币凑成的数额n = (仅使用前i-1种硬币凑成n - coins[i] * k) + (单独使用k个第i种硬币凑成coins[i] * k)")]),n._v(" "),i("p",[n._v("即前i种硬币凑成n的最少硬币个数的状态转移方程为：")]),n._v(" "),i("p",[i("code",[n._v("f(n, i) = min{ f(n - coins[i] * k, i - 1) + k } (k >= 0 & coins[i] * k <= n)")])]),n._v(" "),i("pre",[i("code",[n._v("function coinsMinSolution(coins, n) {\n  coins.sort((a, b) => a - b);\n\n  function getMin(n, i) {\n    // 仅使用第1种硬币时，n能整除面值，则数量为n/面值，否则设为无穷大，在后面的Math.min比较时忽略此解法 \n    if (i === 0) {\n      return n % coins[0] === 0 ? n / coins[0] : Infinity;\n    }\n\n    // 写出状态转移方程，循环k来测试它，找出其最小值\n    const solutions = [];\n    for (let k = 0; coins[i] * k <= n; k++) {\n      solutions.push(getMin(n - coins[i] * k, i - 1) + k);\n    }\n    return Math.min(...solutions);\n  }\n\n  return getMin(n, coins.length - 1);\n}\n")])]),n._v(" "),i("h2",{attrs:{id:"多个有序数组合并"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#多个有序数组合并","aria-hidden":"true"}},[n._v("#")]),n._v(" 多个有序数组合并")]),n._v(" "),i("pre",[i("code",[n._v("const arr1 = [2,5,7];\nconst arr2 = [1,4,7,9];\nconst arr3 = [0,3,4,8];\n\nfunction mergeOrderedArr(arrs) {\n  const result = new Array(arrs.reduce((acc, arr) => acc + arr.length, 0)); // 排序结果数组\n  const idxArr = new Array(arrs.length).fill(0); // idx数组，idx对应arrs的每个arr，表示各个arr当前遍历到的位置\n\n  // 在每个arr剩余的第一项中进行对比，最小的取出放入result，并且该数组idx+1表示该项已被取出\n  for (let i = 0; i < result.length; i++) {\n    let min = Infinity;\n    let minArr = 0;\n\n    for (let j = 0; j < arrs.length; j++) {\n      let num = arrs[j][idxArr[j]];\n\n      if (min > num) {\n        min = num;\n        minArr = j;\n      }\n    }\n\n    idxArr[minArr] = idxArr[minArr] + 1;\n    result[i] = min;\n  }\n\n  return result;\n}\n\nmergeOrderedArr([arr1, arr2, arr3]); // [0, 1, 2, 3, 4, 4, 5, 7, 7, 8, 9]\n")])]),n._v(" "),i("h2",{attrs:{id:"连续子数组的最大和"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#连续子数组的最大和","aria-hidden":"true"}},[n._v("#")]),n._v(" 连续子数组的最大和")]),n._v(" "),i("p",[n._v("用f(i)表示arr中以第i项为结尾的连续子数组的最大和，则其状态转移方程如下")]),n._v(" "),i("p",[i("code",[n._v("f(i) = max{ f(i - 1) + arr[i], arr[i] }")])]),n._v(" "),i("p",[n._v("求出每一个f(i)的值，再从中取最大值作为最后结果")]),n._v(" "),i("p",[i("code",[n._v("result = max{ f(i) } (0 <= i <= arr.length - 1)")])]),n._v(" "),i("pre",[i("code",[n._v("function getMax(arr) {\n\n  // 设置缓存数组，cache[i]表示以第i项为结尾的连续子数组的最大和\n  const cache = [];\n\n  function getMaxEndWithIndex(i) {\n    if (i === 0) {\n      cache[i] = arr[i];\n    }\n    if (!cache[i]) {\n      cache[i] = Math.max(getMaxEndWithIndex(i - 1) + arr[i], arr[i]);\n    }\n    return cache[i];\n  }\n\n  // 计算包含最后一项的子数组的最大和，因为每一项的结果都依赖于前一项，利用此过程递归求出所有项的结果\n  getMaxEndWithIndex(arr.length - 1);\n  \n  return Math.max(...cache);\n\n}\n")])]),n._v(" "),i("h2",{attrs:{id:"求字符串最长不重复子串"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#求字符串最长不重复子串","aria-hidden":"true"}},[n._v("#")]),n._v(" 求字符串最长不重复子串")]),n._v(" "),i("ol",[i("li",[i("p",[n._v("定义start、end两个指针，起始位置为0，初始化max为0")])]),n._v(" "),i("li",[i("p",[n._v("将start、end指向起始位置，初始化缓存列表")])]),n._v(" "),i("li",[i("p",[n._v("end不断向后移动，并将指向的值存入缓存，直到end指向的字母已存在缓存中（说明出现了重复字符），计算end - start的值并与max比较，保留大者")])]),n._v(" "),i("li",[i("p",[n._v("起始位置+1（即start+1），重复步骤2，直到 str.length - start > max 时（此时再继续下去也不会出现更大的max），停止循环，输出max")]),n._v(" "),i("p",[n._v("function lengthOfLongestSubstring(str) {\nlet start = 0;\nlet end = 0;\nlet max = 0;\nwhile (str.length - start > max) {\nend = start;\nconst charCache = new Set();\nwhile (true) {\nconst char = str[end];\nif (!char || charCache.has(char)) {\nmax = Math.max(max, end - start);\nbreak;\n}\ncharCache.add(char);\nend++;\n}\nstart++;\n}\nreturn max;\n};")])])])])},[],!1,null,null,null);t.default=e.exports}}]);