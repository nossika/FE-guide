(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{240:function(t,v,a){"use strict";a.r(v);var r=a(0),_=Object(r.a)({},function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"v8引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎","aria-hidden":"true"}},[t._v("#")]),t._v(" V8引擎")]),t._v(" "),a("h2",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性","aria-hidden":"true"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("p",[t._v("V8是google开源的JS引擎，由C++编写，被应用于Chrome、NodeJS等，其他JS引擎有Rhino、JavaScriptCore、Chakra等。")]),t._v(" "),a("p",[t._v("V8采用的性能优化方式：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Just-In-Time（JIT）编译优化")])]),t._v(" "),a("li",[a("p",[t._v("内联缓存")])])]),t._v(" "),a("p",[t._v("多个对象尽可能共用隐藏类，缓存各属性字段在内存中的偏移量，能加速属性提取")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("高效垃圾回收")])]),t._v(" "),a("li",[a("p",[t._v("etc.")])])]),t._v(" "),a("h2",{attrs:{id:"jit编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jit编译","aria-hidden":"true"}},[t._v("#")]),t._v(" JIT编译")]),t._v(" "),a("p",[t._v("JS是弱类型动态语言，在源码生成AST以后，就开始边解释边执行，且因为变量类型不固定，运行时需边判断类型边操作，由此有了优化空间。")]),t._v(" "),a("p",[t._v("JIT加入"),a("strong",[t._v("监视器")]),t._v("来分析代码片段的运行情况，如果某代码片段被执行次数越多，则对其进行越深层的优化。因为优化也需要代价，所以加入监视器来对优化收益更高的代码进行更多优化操作，以提高整体执行效率。")]),t._v(" "),a("p",[t._v("当某代码片段进入“warm”阶段，JIT对其进行"),a("strong",[t._v("基线编译")]),t._v("并缓存，下次进入此代码片段时，如果变量类型没变，则直接使用这个编译后的版本来运行，节省再次执行解释的时间。")]),t._v(" "),a("p",[t._v("当某代码片段进入“hot”阶段，JIT会对其作更高效的"),a("strong",[t._v("优化编译")]),t._v("，为此需要做一些假设（比如每次某变量使用的对象都有相同结构），针对这一假设再作优化程度更高的编译。如果某次执行中发现假设出错（比如对象结构变了），则放弃优化编译退回基线编译。如果代码片段多次从优化编译退回基线编译，则放弃对此片段的优化编译。")]),t._v(" "),a("h2",{attrs:{id:"垃圾回收原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 垃圾回收原理")]),t._v(" "),a("p",[t._v("V8采用了分代GC，将内存划分为：")]),t._v(" "),a("ul",[a("li",[t._v("新生代区：大部分对象在此区，区域小但垃圾回收频繁")]),t._v(" "),a("li",[t._v("老生代区：从新生代晋升而来的生存周期长的对象")]),t._v(" "),a("li",[t._v("大对象区：占用空间较大的对象")]),t._v(" "),a("li",[t._v("代码区：唯一拥有执行权限的区域")])]),t._v(" "),a("h3",{attrs:{id:"新生代区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新生代区","aria-hidden":"true"}},[t._v("#")]),t._v(" 新生代区")]),t._v(" "),a("p",[t._v("采用复制算法（scavenge）做垃圾回收（GC）")]),t._v(" "),a("p",[t._v("内存空间分为两半---from区和to区，from区是处于使用状态的内存，新对象都会分配到from区，当GC开始时（如from区存满时），引擎会扫描出活跃对象（从root开始扫描，从root作BFS遍历其能访问的所有对象），复制到to区，这样to区就都为活跃对象，然后交换from区和to区内容，释放to区。")]),t._v(" "),a("p",[t._v("由于此区大部分对象是非活跃，所以复制操作代价小，空间上有一半是处于空置状态（to区），但因为此区空间本身就小，所以可以接受这种空置，牺牲空间带来的好处是只需要作一次复制遍历，而不用进行标记+清除两次遍历。")]),t._v(" "),a("p",[t._v("当此区的对象经过多次GC依然存活，说明其生命周期较长，对象会被移动到老生代区，此过程称为对象晋升。")]),t._v(" "),a("h3",{attrs:{id:"老生代区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#老生代区","aria-hidden":"true"}},[t._v("#")]),t._v(" 老生代区")]),t._v(" "),a("p",[t._v("采用标记-清除算法（mark-sweep）做GC")]),t._v(" "),a("p",[t._v("不再采用复制算法，因为此区空间较大，空置一半的空间太浪费，且大量活跃对象的复制代价大。此算法采用DFS遍历来标记活跃对象，标记结束后将非活跃对象（未被标记的对象）直接清除。")]),t._v(" "),a("p",[t._v("标记-清除操作会产生内存碎片（内存空间不连续），当空间不足时执行标记-整理算法（mark-compact）来整理内存。")])])},[],!1,null,null,null);v.default=_.exports}}]);