
# 加密

### RSA非对称加密

#### 用法

密钥a：e（指数），n（模）
密钥b：d（指数），n（模）

用密钥a把M加密为C：C = M ** e (mod n)
用密钥b把C还原为M：M = C ** d (mod n)

也可以反过来用密钥b加密，密钥a还原，从数学上密钥a、b完全可以交换使用。但在实际运用中，一般会生成一个指数较小的（或者固定的）数作为公钥开放（客户端使用起来更方便），指数较大的数作为私钥。如果将它们交换，相当于用一个指数较小的数作为私钥，较容易被反推出来，不安全。

#### 密钥对生成

生成e，d，n过程：

1、选取两个足够大的素数：p、q

2、n = p * q

3、m = (p - 1) * (q - 1)

4、找一个与m互质的数e，且1 < e < m

5、找出d，使得d * e (mod m) = 1

6、生成完毕，密钥a：(e, n)，密钥b：(d, n)

#### 安全性

安全性是基于：大素数分解困难。在这个条件成立的前提下，通过已知的大素数n难以反推出p、q，所以也难以推出e、d，因此密钥a、b虽然可以相互加密解密，但算出另一密钥是困难的。

#### 例子

生成密钥对

1、选取两个素数 p = 3 ，q = 11（为方便举例选取了较小的素数）

2、n = p * q = 3 * 11 = 33

3、m = (p - 1) * (q - 1) = (3 - 1) * (11 - 1) = 20

4、从比m小的数中找出一个与m互质的数 e = 3

5、可以通过穷举法，d从1开始递增，试出满足条件的最小的d = 7

6、得出一对密钥：密钥a：(3, 33)，密钥b：(7, 33)

对'rsa'这个字符串加密

1、对‘rsa’进行数字化转化，'r'，‘s'，’a'可以转化成其对应字母表次序：18、19、1

2、用密钥a加密：

r => 18 => 18 ** 3 % 33 => 24

s => 19 => 19 ** 3 % 33 => 28

a => 1 => 1 ** 3 % 33 => 1

加密后：['r', 's', 'a'] => [24, 28, 1]

对加密后的[24, 28, 1]进行还原

1、用密钥b解密

24 => 24 ** 7 % 33 => 18 => r

28 => 28 ** 7 % 33 => 19 => s

1 => 1 ** 7 % 33 => 1 => a

得出结果'rsa'
