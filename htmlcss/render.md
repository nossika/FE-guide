# 页面渲染

## 渲染过程

页面初次渲染时需要 1. parse HTML 2. DOM解析为DOM tree & CSS解析为CSSOM tree

DOM更新的渲染过程

1. **recalculate style**：计算应用到各元素的css规则
2. **layout**：重新计算各元素位置（即reflow，当仅repaint时此步会跳过）
3. **update layer tree**：更新渲染树
4. **paint**：绘制元素
5. **composite layers**：把各个图层合成为最终结果

## 渲染时机

以chrome为例：

当JS修改了元素样式，不是立刻重新渲染，是把render flag标记为dirty，在**下一个渲染时机**执行完整渲染过程。

**渲染时机**一般为此轮事件循环的结束时，但如果此时距离上次渲染的时间点不足1帧（1帧一般为16.6ms，因环境而异），则推迟到1帧时间以后再渲染。原因是，这1帧时间内可能还有几轮事件循环，其中可能对样式再次修改，提前执行渲染是对性能的浪费。

有时渲染过程中的layout会被提前，而不是等到达渲染时机再执行。如果**同一轮事件循环里**修改了layout相关样式后，又**对layout相关属性进行了读取**，则浏览器会立刻执行recalculate style和layout来得出准确数据，但也只是提前了这2个步骤，后续步骤不影响。

渲染过程中的layout可能被跳过，比如对样式的修改不影响layout，只需repaint而不需reflow。


### 结合例子



## GPU加速

dom的绘制信息会被分成多个格栅上传GPU绘制。

浏览器会按规则把页面分为多个合成层，合成层上的变动只需重绘这个层。

### 创建合成层

某些情况下节点会被单独升级为合成层（比如：transform、opacity、canvas标签、手动加上will-change、有个比自己index低的合成层时 等），浏览器会独立绘制各个合成层，最后再复合而成最终页面，合成层内的dom变动只需要重绘这个层，更高效。

### 结论

- 尽量多用transform
- 在合理时机设置will-change
- 把合成层的index尽可能调高（避免自动创建不必要的合成层）
